pipeline {
  agent any
  options { timestamps() }

  parameters {
    string(name: 'ENDPOINTS_FILE',   defaultValue: 'apis-control/api_endpoints.txt', description: 'Archivo con URLs (una por línea)')
    string(name: 'TIMEOUT_SECONDS',  defaultValue: '10',  description: 'Timeout de curl (--max-time)')
    string(name: 'LATENCY_FAIL_MS',  defaultValue: '2000', description: 'Falla si la latencia supera este umbral (ms)')
    string(name: 'EXPECTED_CODES',   defaultValue: '200,204,403', description: 'Códigos HTTP válidos (coma)')
    text(  name: 'HEADERS',          defaultValue: '', description: 'Cabeceras key=value (una por línea). Se ignoran líneas vacías o con #')
  }

  stages {
    stage('Checkout') {
      steps { checkout scm }
    }

    stage('Comprobar APIs con curl') {
        steps {
            sh '''bash -euo pipefail <<'BASH'
        # --- normaliza ruta del fichero de endpoints ---
        FILE="${ENDPOINTS_FILE:-api_endpoints.txt}"
        case "$FILE" in
        /*) ;;                       # absoluta
        *)  FILE="$WORKSPACE/$FILE" ;;
        esac

        test -f "$FILE" || { echo "No existe $FILE"; exit 1; }
        echo "Leyendo endpoints de: $FILE"

        mkdir -p artifacts

        # --- generar archivo de cabeceras para curl --config ---
        # Si HEADERS no está definido, usa vacío para no romper con -u
        printf '%s\n' "${HEADERS-}" | awk '
        NF && $0 !~ /^[[:space:]]*#/ && index($0,"=")>0 {
            key=$0; sub(/=.*/,"",key);
            val=$0; sub(/^[^=]*=/,"",val);
            printf "header = %s: %s\\n", key, val
        }
        ' > artifacts/curl_headers.txt

        # --- filtrar URLs (sin vacías ni comentarios) ---
        awk 'NF && $0 !~ /^[[:space:]]*#/' "$FILE" > artifacts/urls.txt
        if [ ! -s artifacts/urls.txt ]; then
        echo "No hay URLs válidas en $FILE"
        exit 1
        fi

        # --- códigos esperados ---
        EXP="${EXPECTED_CODES-200,403}"
        IFS=',' read -r -a OK_CODES <<< "$EXP"

        LOG="artifacts/api_checks.log"
        : > "$LOG"
        EXIT=0

        while IFS= read -r url; do
        echo "Probando: $url"

        # Elige método: GET por defecto. Si quieres OPTIONS, descomenta la línea con -X OPTIONS
        CURL_METHOD_OPTS=()
        CURL_METHOD_OPTS=(-X OPTIONS)

        # Ejecutar curl: código + tiempo total (seg)
        read -r CODE SECS <<< "$(curl -sS -o /dev/null -w "%{http_code} %{time_total}" \
            --connect-timeout "${TIMEOUT_SECONDS}" --max-time "${TIMEOUT_SECONDS}" \
            --config artifacts/curl_headers.txt \
            "${CURL_METHOD_OPTS[@]}" \
            "$url" || true)"

        # Convertir a ms
        MS=$(awk -v s="$SECS" 'BEGIN{printf("%.0f", s*1000)}')

        # ¿código esperado?
        OK=0
        for c in "${OK_CODES[@]}"; do
            [ "$CODE" = "$c" ] && OK=1 && break
        done

        if [ "$OK" -eq 1 ]; then
            if [ "$MS" -gt "${LATENCY_FAIL_MS}" ]; then
            echo "❌ $url -> $CODE, latencia ${MS}ms > ${LATENCY_FAIL_MS}ms" | tee -a "$LOG"
            EXIT=1
            else
            echo "✅ $url -> $CODE (${MS} ms)" | tee -a "$LOG"
            fi
        else
            echo "❌ $url -> $CODE (no está en EXPECTED_CODES=${EXP})" | tee -a "$LOG"
            EXIT=1
        fi
        done < artifacts/urls.txt

        echo; echo "Resumen:"; cat "$LOG"
        exit "$EXIT"
        BASH'''
        }
        post {
            always {
            archiveArtifacts artifacts: 'artifacts/**', fingerprint: true, allowEmptyArchive: true
            }
        }
    }

  }

  post {
    success { echo '✅ Comprobación OK' }
    failure { echo '❌ Alguna API falló (código o latencia)' }
  }
}
