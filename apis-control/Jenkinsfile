pipeline {
  agent any

  options { timestamps() }

  parameters {
    string(name: 'ENDPOINTS_FILE', defaultValue: 'api_endpoints.txt', description: 'Ruta del archivo con URLs (una por línea)')
    string(name: 'TIMEOUT_SECONDS', defaultValue: '10', description: 'Timeout por petición')
    string(name: 'EXPECTED_CODES', defaultValue: '200,403', description: 'Códigos HTTP válidos, separados por coma')
    text(name: 'HEADERS', defaultValue: '', description: 'Cabeceras: una por línea, formato key=value. Se ignoran líneas vacías o que empiezan por #')
    string(name: 'LATENCY_FAIL_MS', defaultValue: '2000', description: 'Falla si la latencia supera este umbral (ms)')
  }

  stages {
    stage('Checkout') {
      steps { checkout scm }
    }

    stage('Preparar Python') {
      steps {
        sh '''
          set -e
          if command -v python3 >/dev/null 2>&1; then PY=python3; else PY=python; fi
          $PY -m venv .venv || true
          . .venv/bin/activate
          python -m pip install --upgrade pip >/dev/null
          pip install requests >/dev/null
        '''
      }
    }

    stage('Comprobar APIs') {
      steps {
        sh '''
          set -e
          . .venv/bin/activate
          python - <<'PY'
import os, sys, time, requests

endpoints_file = os.environ.get('ENDPOINTS_FILE', 'api_endpoints.txt')
timeout = float(os.environ.get('TIMEOUT_SECONDS', '10'))
expected_codes = {c.strip() for c in os.environ.get('EXPECTED_CODES','200').split(',') if c.strip()}
latency_fail_ms = int(os.environ.get('LATENCY_FAIL_MS','2000'))

# Parseo de cabeceras key=value, se ignoran vacías o que empiezan por #
headers = {}
for raw in os.environ.get('HEADERS','').splitlines():
    line = raw.strip()
    if not line or line.lstrip().startswith('#') or '=' not in line:
        continue
    k, v = line.split('=', 1)
    headers[k.strip()] = v.strip()

# Leer URLs
try:
    with open(endpoints_file, 'r') as f:
        urls = [ln.strip() for ln in f if ln.strip() and not ln.lstrip().startswith('#')]
except FileNotFoundError:
    print(f"ERROR: No existe {endpoints_file}")
    sys.exit(1)

if not urls:
    print("ERROR: No hay URLs para comprobar.")
    sys.exit(1)

os.makedirs('artifacts', exist_ok=True)
log_path = 'artifacts/api_checks.log'
fail = False

with open(log_path, 'w', encoding='utf-8') as log:
    for url in urls:
        t0 = time.perf_counter()
        try:
            resp = requests.get(url, headers=headers, timeout=timeout)
            ms = int((time.perf_counter() - t0) * 1000)
            code = str(resp.status_code)
            if code in expected_codes:
                if ms > latency_fail_ms:
                    msg = f"❌ {url} -> {code}, latencia {ms}ms > {latency_fail_ms}ms"
                    print(msg); log.write(msg + "\\n"); fail = True
                else:
                    msg = f"✅ {url} -> {code} ({ms} ms)"
                    print(msg); log.write(msg + "\\n")
            else:
                body = (resp.text or '')[:200].replace('\\n',' ')
                msg = f"❌ {url} -> {code} (esperados {sorted(expected_codes)}). Body: {body}..."
                print(msg); log.write(msg + "\\n"); fail = True
        except requests.RequestException as e:
            msg = f"❌ {url} Error: {e}"
            print(msg); log.write(msg + "\\n"); fail = True

print("\\nResumen guardado en artifacts/api_checks.log")
sys.exit(1 if fail else 0)
PY
        '''
      }
      post {
        always {
          archiveArtifacts artifacts: 'artifacts/**', fingerprint: true, allowEmptyArchive: true
        }
      }
    }
  }

  post {
    success { echo '✅ Comprobación OK' }
    failure { echo '❌ Alguna API falló (código o latencia)' }
  }
}
